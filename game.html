<!doctype>
<!-- Tutorial for rays: ncase.me/sight-and-light -->
<!-- Little svg's https://codepen.io/collection/DRMKdB?cursor=ZD0wJm89MCZwPTEmdj00 -->
<html>
		<head><meta charset="utf-8" />
		<style>
			canvas{
				/* background: url(background.svg); */
				background: linear-gradient(to bottom right,indigo,black,black,indigo);
			}
		</style>
		</head> 
		<body style="margin:0;overflow: hidden;">
			<canvas id=a>   
			</canvas>
	</body>
</html>
<script>
// initialize 2D a (c)
// initialize game state (s)
// initialize keys states (u,r,d,l for directions, k for all the keyboard)
c = a.getContext`2d`, k = [u = r = d = l = s = 0]
a.width = innerWidth;
a.height = innerHeight;
// (initialize your global variables here)
c.w = innerWidth;
c.h = innerHeight;
// update u,l,d,r globals when an arrow key/wasd/zqsd is pressed or released
// update k[keyCode] if any other key is pressed/released
onkeydown = onkeyup = e => k[e.which] = self['lld*rlurdu'[e.which % 32 % 17]] = e.type[5];
// Set up variables

numnpcs = 50,
    npcs = [];
for (let i = 0; i < numnpcs; i += 1) {
    spawnnpc();
}

// Find intersection of RAY & SEGMENT
function getIntersection(ray,segment){

	// RAY in parametric: Point + Delta*T1
	var r_px = ray.a.x;
	var r_py = ray.a.y;
	var r_dx = ray.b.x-ray.a.x;
	var r_dy = ray.b.y-ray.a.y;

	// SEGMENT in parametric: Point + Delta*T2
	var s_px = segment.a.x;
	var s_py = segment.a.y;
	var s_dx = segment.b.x-segment.a.x;
	var s_dy = segment.b.y-segment.a.y;

	// Are they parallel? If so, no intersect
	var r_mag = Math.sqrt(r_dx*r_dx+r_dy*r_dy);
	var s_mag = Math.sqrt(s_dx*s_dx+s_dy*s_dy);
	if(r_dx/r_mag==s_dx/s_mag && r_dy/r_mag==s_dy/s_mag){
		// Unit vectors are the same.
		return null;
	}

	// SOLVE FOR T1 & T2
	// r_px+r_dx*T1 = s_px+s_dx*T2 && r_py+r_dy*T1 = s_py+s_dy*T2
	// ==> T1 = (s_px+s_dx*T2-r_px)/r_dx = (s_py+s_dy*T2-r_py)/r_dy
	// ==> s_px*r_dy + s_dx*T2*r_dy - r_px*r_dy = s_py*r_dx + s_dy*T2*r_dx - r_py*r_dx
	// ==> T2 = (r_dx*(s_py-r_py) + r_dy*(r_px-s_px))/(s_dx*r_dy - s_dy*r_dx)
	var T2 = (r_dx*(s_py-r_py) + r_dy*(r_px-s_px))/(s_dx*r_dy - s_dy*r_dx);
	var T1 = (s_px+s_dx*T2-r_px)/r_dx;

	// Must be within parametic whatevers for RAY/SEGMENT
	if(T1<0) return null;
	if(T2<0 || T2>1) return null;

	// Return the POINT OF INTERSECTION
	return {
		x: r_px+r_dx*T1,
		y: r_py+r_dy*T1,
		param: T1
	};

}

function getSightPolygon(sightX,sightY){

	// Get all unique points
	var points = (function(segments){
		var a = [];
		segments.forEach(function(seg){
			a.push(seg.a,seg.b);
		});
		return a;
	})(segments);
	var uniquePoints = (function(points){
		var set = {};
		return points.filter(function(p){
			var key = p.x+","+p.y;
			if(key in set){
				return false;
			}else{
				set[key]=true;
				return true;
			}
		});
	})(points);

	// Get all angles
	var uniqueAngles = [];
	for(var j=0;j<uniquePoints.length;j++){
		var uniquePoint = uniquePoints[j];
		var angle = Math.atan2(uniquePoint.y-sightY,uniquePoint.x-sightX);
		uniquePoint.angle = angle;
		uniqueAngles.push(angle-0.00001,angle,angle+0.00001);
	}

	// RAYS IN ALL DIRECTIONS
	var intersects = [];
	for(var j=0;j<uniqueAngles.length;j++){
		var angle = uniqueAngles[j];

        var closestIntersect = findIntersect(angle, sightX, sightY);
        // Intersect angle
		if(!closestIntersect) continue;
		closestIntersect.angle = angle;
        // Add to list of intersects
		intersects.push(closestIntersect);
    }

    // // every direction
	for(var angle=0;angle<Math.PI*2;angle+=(Math.PI*2)/50){

		// Calculate dx & dy from angle
		var dx = Math.cos(angle);
		var dy = Math.sin(angle);

		// Ray from center of screen to SpaceRay
		var ray = {
			a:{x:SpaceRay.x,y:SpaceRay.y},
			b:{x:SpaceRay.x+dx,y:SpaceRay.y+dy}
		};

		// Find CLOSEST intersection
		var closestIntersect = null;
		for(var i=0;i<segments.length;i++){
			var intersect = getIntersection(ray,segments[i]);
			if(!intersect) continue;
			if(!closestIntersect || intersect.param<closestIntersect.param){
				closestIntersect=intersect;
			}
		}

		// Add to list of intersects
		intersects.push(closestIntersect);

	}


	// Sort intersects by angle
	intersects = intersects.sort(function(a,b){
		return a.angle-b.angle;
	});

	// Polygon is intersects, in order of angle
	return intersects;

}

function findIntersect(angle, sightX, sightY){
    		// Calculate dx & dy from angle
		var dx = Math.cos(angle);
		var dy = Math.sin(angle);

		// Ray from center of screen to SpaceRay
		var ray = {
			a:{x:sightX,y:sightY},
			b:{x:sightX+dx,y:sightY+dy}
		};

		// Find CLOSEST intersection
		var closestIntersect = null;
		for(var i=0;i<segments.length;i++){
			var intersect = getIntersection(ray,segments[i]);
			if(!intersect) continue;
			if(!closestIntersect || intersect.param<closestIntersect.param){
				closestIntersect=intersect;
			}
		}

		return closestIntersect;
}

///////////////////////////////////////////////////////

  


// DRAWING
var foreground = new Image();
foreground.src = "AlienRay.svg"
var background = new Image();
background.src = "background.svg"

function draw(){

	// Clear a
	c.clearRect(0,0,a.width,a.height);

	// Sight Polygons
	var fuzzyRadius = 10;
	var polygons = [getSightPolygon(SpaceRay.x,SpaceRay.y)];
	for(var angle=0;angle<Math.PI*2;angle+=(Math.PI*2)/10){
		var dx = Math.cos(angle)*fuzzyRadius;
		var dy = Math.sin(angle)*fuzzyRadius;
		polygons.push(getSightPolygon(SpaceRay.x+dx,SpaceRay.y+dy));
	};

	// DRAW AS A GIANT POLYGON
	for(var i=1;i<polygons.length;i++){
		drawPolygon(polygons[i],c,"rgba(255,255,255,0.2)");
	}
	drawPolygon(polygons[0],c,"#fff");

    // Draw segments
	c.strokeStyle = "#999";
	for(var i=0;i<segments.length;i++){
		var seg = segments[i];
		c.beginPath();
		c.moveTo(seg.a.x,seg.a.y);
		c.lineTo(seg.b.x,seg.b.y);
		c.stroke();
	}

	// Masked Foreground
	c.globalCompositeOperation = "source-in";
	c.drawImage(foreground,0,0);
	c.globalCompositeOperation = "source-over";

	// Draw dots
	c.fillStyle = "#fff";
	c.beginPath();
    c.arc(SpaceRay.x, SpaceRay.y, 2, 0, 2*Math.PI, false);
    c.fill();
	for(var angle=0;angle<Math.PI*2;angle+=(Math.PI*2)/10){
		var dx = Math.cos(angle)*fuzzyRadius;
		var dy = Math.sin(angle)*fuzzyRadius;
		c.beginPath();
    	c.arc(SpaceRay.x+dx, SpaceRay.y+dy, 2, 0, 2*Math.PI, false);
    	c.fill();
    }

}

function drawPolygon(polygon,c,fillStyle){
	c.fillStyle = fillStyle;
	c.beginPath();
	adjust = findAdjust(SpaceRay.x,SpaceRay.y,polygon[0].x,polygon[0].y);
	c.moveTo(adjust.x,adjust.y);
	for(var i=1;i<polygon.length;i++){
		var intersect = polygon[i];
		adjust = findAdjust(SpaceRay.x,SpaceRay.y,intersect.x,intersect.y);
		c.lineTo(adjust.x,adjust.y);
	}
	c.fill();
}

// This function finds endpoint for shorter ray.
function findAdjust(x1,y1,x2,y2){
	var actualDistance = Math.sqrt(((x2-x1)**2)+((y2-y1)**2));
	var preferedDistance = 80;
	var ratio = preferedDistance/actualDistance;
	// Shorten unless line intersects within that distance
	if(ratio>0 && ratio<1){
		return {x:(1-ratio)*x1+ratio*x2, y:(1-ratio)*y1+ratio*y2};
	}else{
		return {x:x2,y:y2};
	};
}

// LINE SEGMENTS
var segments = [

	// Border
	{a:{x:0,y:0}, b:{x:c.w,y:0}},
	{a:{x:c.w,y:0}, b:{x:c.w,y:c.h}},
	{a:{x:c.w,y:c.h}, b:{x:0,y:c.h}},
	{a:{x:0,y:c.h}, b:{x:0,y:0}},

	// Polygon #3
	{a:{x:200,y:260}, b:{x:220,y:150}},
	{a:{x:220,y:150}, b:{x:300,y:200}},
	{a:{x:300,y:200}, b:{x:350,y:320}},
	{a:{x:350,y:320}, b:{x:200,y:260}},

	// Polygon #5
	{a:{x:650,y:190}, b:{x:760,y:170}},
	{a:{x:760,y:170}, b:{x:740,y:270}},
	{a:{x:740,y:270}, b:{x:630,y:290}},
	{a:{x:630,y:290}, b:{x:650,y:190}},

	// Polygon #6
	{a:{x:600,y:95}, b:{x:780,y:50}},
	{a:{x:780,y:50}, b:{x:680,y:150}},
	{a:{x:680,y:150}, b:{x:600,y:95}}

];

function randomPolygons(polygon){
	let m1,m2,m3,m4,m5,m6;
	m1=0;m2=0;
	let s1 = c.w/7;
	let s2 = c.h/5;
	for(let x=0;x<7;x++){
		for(let y=0;y<4;y++){
			m1=s1*Math.random()*.8+(s1*x);
			m2=s2*Math.random()*.8+(s2*y);
			m3=rS()+m1;
			m4=rS()+m2;
			m5=rS()+m4;
			polygon.push({a:{x:m1,y:m2}, b:{x:m3,y:m4}});
			polygon.push({a:{x:m3,y:m4}, b:{x:m3,y:m5}});
			m4=m3-rS();
			m6=m5-rS()*.5;
			polygon.push({a:{x:m3,y:m5}, b:{x:m4,y:m6}});
			polygon.push({a:{x:m4,y:m6}, b:{x:m1,y:m2}});
}}}
	

function rS(){
	//length of side 20 - 50
	return Math.random()*60+20;
}

randomPolygons(segments);

// DRAW LOOP
// start game loop (60fps)
// the canvas is cleared and adjusted to fullscreen at each frame
setInterval(e => {
    a.width = innerWidth, a.height = innerHeight;
    switch (s) {
        case 0: title();
            break;
        case 1:
			game();
            break;
    }
}, 16)

// handle click/touch events
// globals x and y contain the pointer's coordinates
// in each screen, you can make a click update the game state
// ex: "game over if we click on the bottom half of the screen" => `if(y>h/2)s=3;`
onclick = e => {
    x = e.pageX; y = e.pageY;
    switch (s) {
        case 0:
			dropnpc();
			s=1;
            break;
        case 1: ;
            break;
    }
}

function title() {
    c.w = a.width;
    c.h = a.height;
	draw();

	c.fillStyle = '#4B0082';
    c.fillRect(c.w/4, c.h/3, c.w/2, c.h/2);
	c.fillStyle = '#000000';
    c.fillRect(c.w/4+10, c.h/3+10, c.w/2-20, c.h/2-20);
    
    tx("Space Invasion Simulator", c.w / 2, c.h * .55, 4, '#a4f3f4');
    tx("Save the tiny humans from mass casualties!", c.w / 2, c.h * .62, 1.7, '#a4f3f4');
    
    tx('CLICK TO START!', c.w /2, c.h * .75, 1.5, '#a4f3f4');

}

function game(){
	draw();
	tx("Space Invasion Simulator", c.w / 2, c.h/10, 2, '#a4f3f4');
	spriteCollisions();
	for (i = 0; i < npcs.length; i++) {
		for (let j = 0; j < npcs.length; j++) {
			if(npcs[i].isClose(npcs[j].x,npcs[j].x,4)){
				npcs[i].s.x = npcs[j].s.x;
				npcs[i].s.y = npcs[j].s.y;
			}
		}
		npcs[i].move();
        npcs[i].update();
        npcs[i].render();
    }
}




// SpaceRay	
var SpaceRay = {
	x: a.width/2,
	y: a.height/2
};
// TODO replace with automated movement
a.onmousemove = function(event){	
	SpaceRay.x = event.clientX;
	SpaceRay.y = event.clientY;
	updatea = true;
};

function tx(t, w, h, f, s) {
    c.textAlign = 'center';
    c.fillStyle = s;
    c.font = f + 'vw Arial';
    c.fillText(t, w, h);
}
/////////////////////////////////////////////
// SPRITE STUFF

function sprite(options) {

var that = {},
	frameIndex = 0,
	tickCount = 0,
	spot = 0,
	ticksPerFrame = options.ticksPerFrame || 0,
	numberOfFrames = options.numberOfFrames || 1;

that.context = options.context;
that.w = options.width;
that.h = options.height;
that.x = options.x;
that.y = options.y;
that.image = options.image;
that.scaleRatio = 1;
that.s = options.s;
that.seq = [];

that.newSeq = function (seq) {
	spot = 0;
	frameIndex = 0;
	that.seq = seq;
};

that.switch = function (x) {
	frameIndex = x;
}

that.update = function () {

	tickCount += 1;

	if (tickCount > ticksPerFrame) {

		tickCount = 0;

		// If the current frame index is in range
		if (frameIndex < numberOfFrames - 1) {
			// Go to the next frame
			frameIndex += 1;
			if (that.seq.length > 0) {
				frameIndex = that.seq[spot];
				spot += 1;
			}
		} else if (that.seq.length < 1) {
			frameIndex = 0;
		}
		if (spot > that.seq.length - 1) {
			spot = 0;
		}
	}
};
that.render = function () {
	that.context.shadowOffsetX = 1;
	that.context.shadowOffsetY = 1;
	that.context.shadowColor = "black";
	that.context.shadowBlur = 1;

	// Draw the animation
	that.context.drawImage(
		that.image,
		frameIndex * that.w / numberOfFrames,
		0,
		that.w / numberOfFrames,
		that.h,
		that.x,
		that.y,
		that.w / numberOfFrames * that.scaleRatio,
		that.h * that.scaleRatio,
	);
};
that.getFrameWidth = function () {
	return that.w / numberOfFrames;
};
that.isClose = function (x, y, t) {
	var dx = (that.x + that.getFrameWidth() / 2 * that.scaleRatio) - (x + that.getFrameWidth() / 2),
		dy = (that.y + that.getFrameWidth() / 2 * that.scaleRatio) - (y + that.getFrameWidth() / 2);

	var dist = Math.sqrt(dx * dx + dy * dy);

	if (dist < that.getFrameWidth() * that.scaleRatio * t) {
		return true;
	} else {
		return false;
	}
}
that.move = function(){
	that.x+= that.s.x;
	that.y+= that.s.y;
	if(that.x>c.w-3){
		that.x = 5;
	}
	if(that.y>c.h-3){
		that.y = 5;
	}
	if(that.x<3){
		that.x = c.w-5;
	}
	if(that.y<3){
		that.y = c.h-5;
	}
}
return that;
}
// End sprite function

function makeSprite(c, w, h, img, f, t, x, y, r, s) {
let i = new Image();
sp = sprite({
	context: c,
	width: w,
	height: h,
	image: i,
	numberOfFrames: f,
	ticksPerFrame: t,
	s: s
});
sp.x = x;
sp.y = y;
sp.scaleRatio = r;
i.src = img;
return sp;
}

function spawnnpc() {
    let i = npcs.length;
    npcs[i] = makeSprite(c, 168, 22, "man3.png", 6, 10, 0, 0, 1, {x:2,y:1});
    npcs[i].dead = false;
	npcs[i].newSeq([0, 0, 1, 1, 2, 2, 1, 1]);
}

function dropnpc(){
	let rX;
	let rY; 
	for (i = 0; i < npcs.length; i++) {
		rX = Math.random()*c.w;
		rY = Math.random()*c.h;
		npcs[i].x = rX;
		npcs[i].y = rY;
		if(i%2==0){
			npcs[i].s.y=-2;
		}
	}
	// Add code to check if inside polygon
}

function minDistance( A,  B,  E)
{
 
    // vector AB
    var AB=[];
    AB.push (B[0] - A[0]);
    AB.push(B[1] - A[1]);
 
    // vector BP
    var BE=[];
    BE.push(E[0] - B[0]);
    BE.push(E[1] - B[1]);
 
    // vector AP
   var AE=[];
    AE.push(E[0] - A[0]),
    AE.push(E[1] - A[1]);
 
    // Variables to store dot product
    var AB_BE, AB_AE;
 
    // Calculating the dot product
    AB_BE=(AB[0] * BE[0] + AB[1] * BE[1]);
    AB_AE=(AB[0] * AE[0] + AB[1] * AE[1]);
 
    // Minimum distance from
    // point E to the line segment
    var reqAns = 0;
 
    // Case 1
    if (AB_BE > 0) {
 
        // Finding the magnitude
        var y = E[1] - B[1];
        var x = E[0] - B[0];
        reqAns = Math.sqrt(x * x + y * y);
    }
 
    // Case 2
    else if (AB_AE < 0) {
        var y = E[1] - A[1];
        var x = E[0] - A[0];
        reqAns = Math.sqrt(x * x + y * y);
    }
 
    // Case 3
    else {
 
        // Finding the perpendicular distance
       var x1 = AB[0];
        var y1 = AB[1];
       var x2 = AE[0];
        var y2 = AE[1];
        var mod = Math.sqrt(x1 * x1 + y1 * y1);
        reqAns = Math.abs(x1 * y2 - y1 * x2) / mod;
    }
    return reqAns;
}

 
function spriteCollisions(){
	for(i=0;i<segments.length;i++){
		for(let j=0;j<npcs.length;j++){
			if(minDistance([segments[i].a.x,segments[i].a.y],
				[segments[i].b.x,segments[i].b.y],
				[npcs[j].x,npcs[j].y])<3){
					npcs[j].s.x=-npcs[j].s.x;
					npcs[j].s.y= npcs[j].s.y;
				}
		}
	}	
}
</script>
